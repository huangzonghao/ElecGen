// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: component_structure.proto

#ifndef PROTOBUF_component_5fstructure_2eproto__INCLUDED
#define PROTOBUF_component_5fstructure_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace Electronics {
class Battery;
class BatteryDefaultTypeInternal;
extern BatteryDefaultTypeInternal _Battery_default_instance_;
class Bluetooth;
class BluetoothDefaultTypeInternal;
extern BluetoothDefaultTypeInternal _Bluetooth_default_instance_;
class Camera;
class CameraDefaultTypeInternal;
extern CameraDefaultTypeInternal _Camera_default_instance_;
class Component;
class ComponentDefaultTypeInternal;
extern ComponentDefaultTypeInternal _Component_default_instance_;
class Force_Sensor;
class Force_SensorDefaultTypeInternal;
extern Force_SensorDefaultTypeInternal _Force_Sensor_default_instance_;
class H_Bridge;
class H_BridgeDefaultTypeInternal;
extern H_BridgeDefaultTypeInternal _H_Bridge_default_instance_;
class Micro_Controller;
class Micro_ControllerDefaultTypeInternal;
extern Micro_ControllerDefaultTypeInternal _Micro_Controller_default_instance_;
class Motor;
class MotorDefaultTypeInternal;
extern MotorDefaultTypeInternal _Motor_default_instance_;
class Voltage_Regulator;
class Voltage_RegulatorDefaultTypeInternal;
extern Voltage_RegulatorDefaultTypeInternal _Voltage_Regulator_default_instance_;
class bbox;
class bboxDefaultTypeInternal;
extern bboxDefaultTypeInternal _bbox_default_instance_;
class bounds;
class boundsDefaultTypeInternal;
extern boundsDefaultTypeInternal _bounds_default_instance_;
class dependence;
class dependenceDefaultTypeInternal;
extern dependenceDefaultTypeInternal _dependence_default_instance_;
class lin_cons;
class lin_consDefaultTypeInternal;
extern lin_consDefaultTypeInternal _lin_cons_default_instance_;
class pin;
class pinDefaultTypeInternal;
extern pinDefaultTypeInternal _pin_default_instance_;
}  // namespace Electronics

namespace Electronics {

namespace protobuf_component_5fstructure_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_component_5fstructure_2eproto

enum RELATION {
  EQUAL = 0,
  LESS = 1,
  GREATER = 2
};
bool RELATION_IsValid(int value);
const RELATION RELATION_MIN = EQUAL;
const RELATION RELATION_MAX = GREATER;
const int RELATION_ARRAYSIZE = RELATION_MAX + 1;

const ::google::protobuf::EnumDescriptor* RELATION_descriptor();
inline const ::std::string& RELATION_Name(RELATION value) {
  return ::google::protobuf::internal::NameOfEnum(
    RELATION_descriptor(), value);
}
inline bool RELATION_Parse(
    const ::std::string& name, RELATION* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RELATION>(
    RELATION_descriptor(), name, value);
}
enum IO {
  IN = 4,
  OUT = 5,
  BIDIRECT = 6
};
bool IO_IsValid(int value);
const IO IO_MIN = IN;
const IO IO_MAX = BIDIRECT;
const int IO_ARRAYSIZE = IO_MAX + 1;

const ::google::protobuf::EnumDescriptor* IO_descriptor();
inline const ::std::string& IO_Name(IO value) {
  return ::google::protobuf::internal::NameOfEnum(
    IO_descriptor(), value);
}
inline bool IO_Parse(
    const ::std::string& name, IO* value) {
  return ::google::protobuf::internal::ParseNamedEnum<IO>(
    IO_descriptor(), name, value);
}
enum CLASS {
  POWER = 7,
  FUNCTION = 8,
  BOTH = 9
};
bool CLASS_IsValid(int value);
const CLASS CLASS_MIN = POWER;
const CLASS CLASS_MAX = BOTH;
const int CLASS_ARRAYSIZE = CLASS_MAX + 1;

const ::google::protobuf::EnumDescriptor* CLASS_descriptor();
inline const ::std::string& CLASS_Name(CLASS value) {
  return ::google::protobuf::internal::NameOfEnum(
    CLASS_descriptor(), value);
}
inline bool CLASS_Parse(
    const ::std::string& name, CLASS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CLASS>(
    CLASS_descriptor(), name, value);
}
enum FUNCTION_TYPE {
  ELECTRICAL = 10,
  COMMUNICATION = 11,
  FW_UPDATE = 12,
  RESET = 13,
  MODE = 14,
  LOGIC = 15,
  MOTOR = 16,
  ENABLE = 17,
  GND = 18,
  OTHER = 19,
  PWM = 20,
  DIGITAL = 21,
  ANALOG = 22,
  EXTERNAL_INTERRUPT = 23,
  SPI_SCK = 24,
  SPI_MOSI = 25,
  SPI_MISO = 26,
  SPI_SS = 27,
  I2C_SDA = 28,
  I2C_SCL = 29,
  UART_TX = 30,
  UART_RX = 31,
  DIGITAL_UART_TX = 32,
  DIGITAL_UART_RX = 33,
  DIGITAL_SPI_SCK = 34,
  DIGITAL_SPI_MOSI = 35,
  DIGITAL_SPI_MISO = 36,
  DIGITAL_SPI_SS = 37,
  DIGITAL_EXTERNAL_INTERRUPT = 38,
  PWM_EXTERNAL_INTERRUPT = 39,
  PWM_SPI_SCK = 40,
  PWM_SPI_MOSI = 41,
  PWM_SPI_MISO = 42,
  PWM_SPI_SS = 43,
  ANALOG_I2C_SDA = 44,
  ANALOG_I2C_SCL = 45,
  UART_RX_I2C_SDA = 46,
  UART_RX_I2C_SCL = 47,
  UART_TX_I2C_SDA = 48,
  UART_TX_I2C_SCL = 49,
  DIGITAL_EXTERNAL_INTERRUPT_I2C_SDA = 50,
  DIGITAL_EXTERNAL_INTERRUPT_I2C_SCL = 51,
  DIGITAL_EXTERNAL_INTERRUPT_UART_RX = 52,
  DIGITAL_EXTERNAL_INTERRUPT_UART_TX = 53,
  ADJUST = 54
};
bool FUNCTION_TYPE_IsValid(int value);
const FUNCTION_TYPE FUNCTION_TYPE_MIN = ELECTRICAL;
const FUNCTION_TYPE FUNCTION_TYPE_MAX = ADJUST;
const int FUNCTION_TYPE_ARRAYSIZE = FUNCTION_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* FUNCTION_TYPE_descriptor();
inline const ::std::string& FUNCTION_TYPE_Name(FUNCTION_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    FUNCTION_TYPE_descriptor(), value);
}
inline bool FUNCTION_TYPE_Parse(
    const ::std::string& name, FUNCTION_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FUNCTION_TYPE>(
    FUNCTION_TYPE_descriptor(), name, value);
}
enum PHYSICAL_TYPE {
  NORMAL = 55,
  USB = 56,
  POWER_JACK = 57
};
bool PHYSICAL_TYPE_IsValid(int value);
const PHYSICAL_TYPE PHYSICAL_TYPE_MIN = NORMAL;
const PHYSICAL_TYPE PHYSICAL_TYPE_MAX = POWER_JACK;
const int PHYSICAL_TYPE_ARRAYSIZE = PHYSICAL_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* PHYSICAL_TYPE_descriptor();
inline const ::std::string& PHYSICAL_TYPE_Name(PHYSICAL_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    PHYSICAL_TYPE_descriptor(), value);
}
inline bool PHYSICAL_TYPE_Parse(
    const ::std::string& name, PHYSICAL_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PHYSICAL_TYPE>(
    PHYSICAL_TYPE_descriptor(), name, value);
}
enum CONNECTION {
  OTO = 39,
  OTM = 40
};
bool CONNECTION_IsValid(int value);
const CONNECTION CONNECTION_MIN = OTO;
const CONNECTION CONNECTION_MAX = OTM;
const int CONNECTION_ARRAYSIZE = CONNECTION_MAX + 1;

const ::google::protobuf::EnumDescriptor* CONNECTION_descriptor();
inline const ::std::string& CONNECTION_Name(CONNECTION value) {
  return ::google::protobuf::internal::NameOfEnum(
    CONNECTION_descriptor(), value);
}
inline bool CONNECTION_Parse(
    const ::std::string& name, CONNECTION* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CONNECTION>(
    CONNECTION_descriptor(), name, value);
}
// ===================================================================

class bbox : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Electronics.bbox) */ {
 public:
  bbox();
  virtual ~bbox();

  bbox(const bbox& from);

  inline bbox& operator=(const bbox& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const bbox& default_instance();

  static inline const bbox* internal_default_instance() {
    return reinterpret_cast<const bbox*>(
               &_bbox_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(bbox* other);

  // implements Message ----------------------------------------------

  inline bbox* New() const PROTOBUF_FINAL { return New(NULL); }

  bbox* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const bbox& from);
  void MergeFrom(const bbox& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(bbox* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double length = 1;
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 1;
  double length() const;
  void set_length(double value);

  // required double width = 2;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 2;
  double width() const;
  void set_width(double value);

  // required double height = 3;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  double height() const;
  void set_height(double value);

  // @@protoc_insertion_point(class_scope:Electronics.bbox)
 private:
  void set_has_length();
  void clear_has_length();
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double length_;
  double width_;
  double height_;
  friend struct protobuf_component_5fstructure_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class bounds : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Electronics.bounds) */ {
 public:
  bounds();
  virtual ~bounds();

  bounds(const bounds& from);

  inline bounds& operator=(const bounds& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const bounds& default_instance();

  static inline const bounds* internal_default_instance() {
    return reinterpret_cast<const bounds*>(
               &_bounds_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(bounds* other);

  // implements Message ----------------------------------------------

  inline bounds* New() const PROTOBUF_FINAL { return New(NULL); }

  bounds* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const bounds& from);
  void MergeFrom(const bounds& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(bounds* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double lb = 1;
  bool has_lb() const;
  void clear_lb();
  static const int kLbFieldNumber = 1;
  double lb() const;
  void set_lb(double value);

  // required double ub = 2;
  bool has_ub() const;
  void clear_ub();
  static const int kUbFieldNumber = 2;
  double ub() const;
  void set_ub(double value);

  // @@protoc_insertion_point(class_scope:Electronics.bounds)
 private:
  void set_has_lb();
  void clear_has_lb();
  void set_has_ub();
  void clear_has_ub();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double lb_;
  double ub_;
  friend struct protobuf_component_5fstructure_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class lin_cons : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Electronics.lin_cons) */ {
 public:
  lin_cons();
  virtual ~lin_cons();

  lin_cons(const lin_cons& from);

  inline lin_cons& operator=(const lin_cons& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lin_cons& default_instance();

  static inline const lin_cons* internal_default_instance() {
    return reinterpret_cast<const lin_cons*>(
               &_lin_cons_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(lin_cons* other);

  // implements Message ----------------------------------------------

  inline lin_cons* New() const PROTOBUF_FINAL { return New(NULL); }

  lin_cons* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const lin_cons& from);
  void MergeFrom(const lin_cons& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(lin_cons* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string var_name = 1;
  int var_name_size() const;
  void clear_var_name();
  static const int kVarNameFieldNumber = 1;
  const ::std::string& var_name(int index) const;
  ::std::string* mutable_var_name(int index);
  void set_var_name(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_var_name(int index, ::std::string&& value);
  #endif
  void set_var_name(int index, const char* value);
  void set_var_name(int index, const char* value, size_t size);
  ::std::string* add_var_name();
  void add_var_name(const ::std::string& value);
  #if LANG_CXX11
  void add_var_name(::std::string&& value);
  #endif
  void add_var_name(const char* value);
  void add_var_name(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& var_name() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_var_name();

  // repeated double coefficient = 2;
  int coefficient_size() const;
  void clear_coefficient();
  static const int kCoefficientFieldNumber = 2;
  double coefficient(int index) const;
  void set_coefficient(int index, double value);
  void add_coefficient(double value);
  const ::google::protobuf::RepeatedField< double >&
      coefficient() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_coefficient();

  // required double constant = 3;
  bool has_constant() const;
  void clear_constant();
  static const int kConstantFieldNumber = 3;
  double constant() const;
  void set_constant(double value);

  // required .Electronics.RELATION type = 4;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::Electronics::RELATION type() const;
  void set_type(::Electronics::RELATION value);

  // @@protoc_insertion_point(class_scope:Electronics.lin_cons)
 private:
  void set_has_constant();
  void clear_has_constant();
  void set_has_type();
  void clear_has_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> var_name_;
  ::google::protobuf::RepeatedField< double > coefficient_;
  double constant_;
  int type_;
  friend struct protobuf_component_5fstructure_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class pin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Electronics.pin) */ {
 public:
  pin();
  virtual ~pin();

  pin(const pin& from);

  inline pin& operator=(const pin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const pin& default_instance();

  static inline const pin* internal_default_instance() {
    return reinterpret_cast<const pin*>(
               &_pin_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(pin* other);

  // implements Message ----------------------------------------------

  inline pin* New() const PROTOBUF_FINAL { return New(NULL); }

  pin* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const pin& from);
  void MergeFrom(const pin& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(pin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required .Electronics.bounds v_bound = 8;
  bool has_v_bound() const;
  void clear_v_bound();
  static const int kVBoundFieldNumber = 8;
  const ::Electronics::bounds& v_bound() const;
  ::Electronics::bounds* mutable_v_bound();
  ::Electronics::bounds* release_v_bound();
  void set_allocated_v_bound(::Electronics::bounds* v_bound);

  // required .Electronics.bounds i_bound = 9;
  bool has_i_bound() const;
  void clear_i_bound();
  static const int kIBoundFieldNumber = 9;
  const ::Electronics::bounds& i_bound() const;
  ::Electronics::bounds* mutable_i_bound();
  ::Electronics::bounds* release_i_bound();
  void set_allocated_i_bound(::Electronics::bounds* i_bound);

  // required .Electronics.dependence dependents = 10;
  bool has_dependents() const;
  void clear_dependents();
  static const int kDependentsFieldNumber = 10;
  const ::Electronics::dependence& dependents() const;
  ::Electronics::dependence* mutable_dependents();
  ::Electronics::dependence* release_dependents();
  void set_allocated_dependents(::Electronics::dependence* dependents);

  // required bool status = 7;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 7;
  bool status() const;
  void set_status(bool value);

  // required .Electronics.CONNECTION connection = 6;
  bool has_connection() const;
  void clear_connection();
  static const int kConnectionFieldNumber = 6;
  ::Electronics::CONNECTION connection() const;
  void set_connection(::Electronics::CONNECTION value);

  // required .Electronics.CLASS pin_class = 2;
  bool has_pin_class() const;
  void clear_pin_class();
  static const int kPinClassFieldNumber = 2;
  ::Electronics::CLASS pin_class() const;
  void set_pin_class(::Electronics::CLASS value);

  // required .Electronics.FUNCTION_TYPE func_type = 3;
  bool has_func_type() const;
  void clear_func_type();
  static const int kFuncTypeFieldNumber = 3;
  ::Electronics::FUNCTION_TYPE func_type() const;
  void set_func_type(::Electronics::FUNCTION_TYPE value);

  // required .Electronics.PHYSICAL_TYPE phys_type = 4;
  bool has_phys_type() const;
  void clear_phys_type();
  static const int kPhysTypeFieldNumber = 4;
  ::Electronics::PHYSICAL_TYPE phys_type() const;
  void set_phys_type(::Electronics::PHYSICAL_TYPE value);

  // required .Electronics.IO io = 5;
  bool has_io() const;
  void clear_io();
  static const int kIoFieldNumber = 5;
  ::Electronics::IO io() const;
  void set_io(::Electronics::IO value);

  // @@protoc_insertion_point(class_scope:Electronics.pin)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_pin_class();
  void clear_has_pin_class();
  void set_has_func_type();
  void clear_has_func_type();
  void set_has_phys_type();
  void clear_has_phys_type();
  void set_has_io();
  void clear_has_io();
  void set_has_connection();
  void clear_has_connection();
  void set_has_status();
  void clear_has_status();
  void set_has_v_bound();
  void clear_has_v_bound();
  void set_has_i_bound();
  void clear_has_i_bound();
  void set_has_dependents();
  void clear_has_dependents();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::Electronics::bounds* v_bound_;
  ::Electronics::bounds* i_bound_;
  ::Electronics::dependence* dependents_;
  bool status_;
  int connection_;
  int pin_class_;
  int func_type_;
  int phys_type_;
  int io_;
  friend struct protobuf_component_5fstructure_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class dependence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Electronics.dependence) */ {
 public:
  dependence();
  virtual ~dependence();

  dependence(const dependence& from);

  inline dependence& operator=(const dependence& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dependence& default_instance();

  static inline const dependence* internal_default_instance() {
    return reinterpret_cast<const dependence*>(
               &_dependence_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(dependence* other);

  // implements Message ----------------------------------------------

  inline dependence* New() const PROTOBUF_FINAL { return New(NULL); }

  dependence* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const dependence& from);
  void MergeFrom(const dependence& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(dependence* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string others = 1;
  int others_size() const;
  void clear_others();
  static const int kOthersFieldNumber = 1;
  const ::std::string& others(int index) const;
  ::std::string* mutable_others(int index);
  void set_others(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_others(int index, ::std::string&& value);
  #endif
  void set_others(int index, const char* value);
  void set_others(int index, const char* value, size_t size);
  ::std::string* add_others();
  void add_others(const ::std::string& value);
  #if LANG_CXX11
  void add_others(::std::string&& value);
  #endif
  void add_others(const char* value);
  void add_others(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& others() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_others();

  // @@protoc_insertion_point(class_scope:Electronics.dependence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> others_;
  friend struct protobuf_component_5fstructure_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Component : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Electronics.Component) */ {
 public:
  Component();
  virtual ~Component();

  Component(const Component& from);

  inline Component& operator=(const Component& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Component& default_instance();

  static inline const Component* internal_default_instance() {
    return reinterpret_cast<const Component*>(
               &_Component_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Component* other);

  // implements Message ----------------------------------------------

  inline Component* New() const PROTOBUF_FINAL { return New(NULL); }

  Component* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Component& from);
  void MergeFrom(const Component& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Component* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Electronics.pin pin = 4;
  int pin_size() const;
  void clear_pin();
  static const int kPinFieldNumber = 4;
  const ::Electronics::pin& pin(int index) const;
  ::Electronics::pin* mutable_pin(int index);
  ::Electronics::pin* add_pin();
  ::google::protobuf::RepeatedPtrField< ::Electronics::pin >*
      mutable_pin();
  const ::google::protobuf::RepeatedPtrField< ::Electronics::pin >&
      pin() const;

  // required string component_name = 1;
  bool has_component_name() const;
  void clear_component_name();
  static const int kComponentNameFieldNumber = 1;
  const ::std::string& component_name() const;
  void set_component_name(const ::std::string& value);
  #if LANG_CXX11
  void set_component_name(::std::string&& value);
  #endif
  void set_component_name(const char* value);
  void set_component_name(const char* value, size_t size);
  ::std::string* mutable_component_name();
  ::std::string* release_component_name();
  void set_allocated_component_name(::std::string* component_name);

  // required string component_type = 2;
  bool has_component_type() const;
  void clear_component_type();
  static const int kComponentTypeFieldNumber = 2;
  const ::std::string& component_type() const;
  void set_component_type(const ::std::string& value);
  #if LANG_CXX11
  void set_component_type(::std::string&& value);
  #endif
  void set_component_type(const char* value);
  void set_component_type(const char* value, size_t size);
  ::std::string* mutable_component_type();
  ::std::string* release_component_type();
  void set_allocated_component_type(::std::string* component_type);

  // required string component_class = 3;
  bool has_component_class() const;
  void clear_component_class();
  static const int kComponentClassFieldNumber = 3;
  const ::std::string& component_class() const;
  void set_component_class(const ::std::string& value);
  #if LANG_CXX11
  void set_component_class(::std::string&& value);
  #endif
  void set_component_class(const char* value);
  void set_component_class(const char* value, size_t size);
  ::std::string* mutable_component_class();
  ::std::string* release_component_class();
  void set_allocated_component_class(::std::string* component_class);

  // required .Electronics.bbox size = 6;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 6;
  const ::Electronics::bbox& size() const;
  ::Electronics::bbox* mutable_size();
  ::Electronics::bbox* release_size();
  void set_allocated_size(::Electronics::bbox* size);

  // required double weight = 7;
  bool has_weight() const;
  void clear_weight();
  static const int kWeightFieldNumber = 7;
  double weight() const;
  void set_weight(double value);

  // required double price = 8;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 8;
  double price() const;
  void set_price(double value);

  // required bool nonlin = 5;
  bool has_nonlin() const;
  void clear_nonlin();
  static const int kNonlinFieldNumber = 5;
  bool nonlin() const;
  void set_nonlin(bool value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Component)
  // @@protoc_insertion_point(class_scope:Electronics.Component)
 private:
  void set_has_component_name();
  void clear_has_component_name();
  void set_has_component_type();
  void clear_has_component_type();
  void set_has_component_class();
  void clear_has_component_class();
  void set_has_nonlin();
  void clear_has_nonlin();
  void set_has_size();
  void clear_has_size();
  void set_has_weight();
  void clear_has_weight();
  void set_has_price();
  void clear_has_price();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Electronics::pin > pin_;
  ::google::protobuf::internal::ArenaStringPtr component_name_;
  ::google::protobuf::internal::ArenaStringPtr component_type_;
  ::google::protobuf::internal::ArenaStringPtr component_class_;
  ::Electronics::bbox* size_;
  double weight_;
  double price_;
  bool nonlin_;
  friend struct protobuf_component_5fstructure_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Motor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Electronics.Motor) */ {
 public:
  Motor();
  virtual ~Motor();

  Motor(const Motor& from);

  inline Motor& operator=(const Motor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Motor& default_instance();

  static inline const Motor* internal_default_instance() {
    return reinterpret_cast<const Motor*>(
               &_Motor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Motor* other);

  // implements Message ----------------------------------------------

  inline Motor* New() const PROTOBUF_FINAL { return New(NULL); }

  Motor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Motor& from);
  void MergeFrom(const Motor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Motor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double kt = 1;
  bool has_kt() const;
  void clear_kt();
  static const int kKtFieldNumber = 1;
  double kt() const;
  void set_kt(double value);

  // optional double ke = 2;
  bool has_ke() const;
  void clear_ke();
  static const int kKeFieldNumber = 2;
  double ke() const;
  void set_ke(double value);

  // optional double r = 3;
  bool has_r() const;
  void clear_r();
  static const int kRFieldNumber = 3;
  double r() const;
  void set_r(double value);

  // optional double vin = 4;
  bool has_vin() const;
  void clear_vin();
  static const int kVinFieldNumber = 4;
  double vin() const;
  void set_vin(double value);

  // optional double i = 5;
  bool has_i() const;
  void clear_i();
  static const int kIFieldNumber = 5;
  double i() const;
  void set_i(double value);

  // optional double torq = 6;
  bool has_torq() const;
  void clear_torq();
  static const int kTorqFieldNumber = 6;
  double torq() const;
  void set_torq(double value);

  // optional double vel = 7;
  bool has_vel() const;
  void clear_vel();
  static const int kVelFieldNumber = 7;
  double vel() const;
  void set_vel(double value);

  static const int kMotorFieldNumber = 101;
  static ::google::protobuf::internal::ExtensionIdentifier< ::Electronics::Component,
      ::google::protobuf::internal::MessageTypeTraits< ::Electronics::Motor >, 11, false >
    motor;
  // @@protoc_insertion_point(class_scope:Electronics.Motor)
 private:
  void set_has_kt();
  void clear_has_kt();
  void set_has_ke();
  void clear_has_ke();
  void set_has_r();
  void clear_has_r();
  void set_has_vin();
  void clear_has_vin();
  void set_has_i();
  void clear_has_i();
  void set_has_torq();
  void clear_has_torq();
  void set_has_vel();
  void clear_has_vel();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double kt_;
  double ke_;
  double r_;
  double vin_;
  double i_;
  double torq_;
  double vel_;
  friend struct protobuf_component_5fstructure_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Voltage_Regulator : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Electronics.Voltage_Regulator) */ {
 public:
  Voltage_Regulator();
  virtual ~Voltage_Regulator();

  Voltage_Regulator(const Voltage_Regulator& from);

  inline Voltage_Regulator& operator=(const Voltage_Regulator& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Voltage_Regulator& default_instance();

  static inline const Voltage_Regulator* internal_default_instance() {
    return reinterpret_cast<const Voltage_Regulator*>(
               &_Voltage_Regulator_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Voltage_Regulator* other);

  // implements Message ----------------------------------------------

  inline Voltage_Regulator* New() const PROTOBUF_FINAL { return New(NULL); }

  Voltage_Regulator* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Voltage_Regulator& from);
  void MergeFrom(const Voltage_Regulator& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Voltage_Regulator* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Electronics.lin_cons cons = 1;
  int cons_size() const;
  void clear_cons();
  static const int kConsFieldNumber = 1;
  const ::Electronics::lin_cons& cons(int index) const;
  ::Electronics::lin_cons* mutable_cons(int index);
  ::Electronics::lin_cons* add_cons();
  ::google::protobuf::RepeatedPtrField< ::Electronics::lin_cons >*
      mutable_cons();
  const ::google::protobuf::RepeatedPtrField< ::Electronics::lin_cons >&
      cons() const;

  static const int kVoltageRegulatorFieldNumber = 106;
  static ::google::protobuf::internal::ExtensionIdentifier< ::Electronics::Component,
      ::google::protobuf::internal::MessageTypeTraits< ::Electronics::Voltage_Regulator >, 11, false >
    voltage_regulator;
  // @@protoc_insertion_point(class_scope:Electronics.Voltage_Regulator)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Electronics::lin_cons > cons_;
  friend struct protobuf_component_5fstructure_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class H_Bridge : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Electronics.H_Bridge) */ {
 public:
  H_Bridge();
  virtual ~H_Bridge();

  H_Bridge(const H_Bridge& from);

  inline H_Bridge& operator=(const H_Bridge& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const H_Bridge& default_instance();

  static inline const H_Bridge* internal_default_instance() {
    return reinterpret_cast<const H_Bridge*>(
               &_H_Bridge_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(H_Bridge* other);

  // implements Message ----------------------------------------------

  inline H_Bridge* New() const PROTOBUF_FINAL { return New(NULL); }

  H_Bridge* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const H_Bridge& from);
  void MergeFrom(const H_Bridge& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(H_Bridge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Electronics.lin_cons linear_cons = 2;
  int linear_cons_size() const;
  void clear_linear_cons();
  static const int kLinearConsFieldNumber = 2;
  const ::Electronics::lin_cons& linear_cons(int index) const;
  ::Electronics::lin_cons* mutable_linear_cons(int index);
  ::Electronics::lin_cons* add_linear_cons();
  ::google::protobuf::RepeatedPtrField< ::Electronics::lin_cons >*
      mutable_linear_cons();
  const ::google::protobuf::RepeatedPtrField< ::Electronics::lin_cons >&
      linear_cons() const;

  // optional .Electronics.bounds logic_level = 1;
  bool has_logic_level() const;
  void clear_logic_level();
  static const int kLogicLevelFieldNumber = 1;
  const ::Electronics::bounds& logic_level() const;
  ::Electronics::bounds* mutable_logic_level();
  ::Electronics::bounds* release_logic_level();
  void set_allocated_logic_level(::Electronics::bounds* logic_level);

  static const int kHBridgeFieldNumber = 102;
  static ::google::protobuf::internal::ExtensionIdentifier< ::Electronics::Component,
      ::google::protobuf::internal::MessageTypeTraits< ::Electronics::H_Bridge >, 11, false >
    h_bridge;
  // @@protoc_insertion_point(class_scope:Electronics.H_Bridge)
 private:
  void set_has_logic_level();
  void clear_has_logic_level();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Electronics::lin_cons > linear_cons_;
  ::Electronics::bounds* logic_level_;
  friend struct protobuf_component_5fstructure_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Micro_Controller : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Electronics.Micro_Controller) */ {
 public:
  Micro_Controller();
  virtual ~Micro_Controller();

  Micro_Controller(const Micro_Controller& from);

  inline Micro_Controller& operator=(const Micro_Controller& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Micro_Controller& default_instance();

  static inline const Micro_Controller* internal_default_instance() {
    return reinterpret_cast<const Micro_Controller*>(
               &_Micro_Controller_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Micro_Controller* other);

  // implements Message ----------------------------------------------

  inline Micro_Controller* New() const PROTOBUF_FINAL { return New(NULL); }

  Micro_Controller* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Micro_Controller& from);
  void MergeFrom(const Micro_Controller& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Micro_Controller* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Electronics.bounds logic_level = 1;
  bool has_logic_level() const;
  void clear_logic_level();
  static const int kLogicLevelFieldNumber = 1;
  const ::Electronics::bounds& logic_level() const;
  ::Electronics::bounds* mutable_logic_level();
  ::Electronics::bounds* release_logic_level();
  void set_allocated_logic_level(::Electronics::bounds* logic_level);

  static const int kMicroControllerFieldNumber = 104;
  static ::google::protobuf::internal::ExtensionIdentifier< ::Electronics::Component,
      ::google::protobuf::internal::MessageTypeTraits< ::Electronics::Micro_Controller >, 11, false >
    micro_controller;
  // @@protoc_insertion_point(class_scope:Electronics.Micro_Controller)
 private:
  void set_has_logic_level();
  void clear_has_logic_level();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::Electronics::bounds* logic_level_;
  friend struct protobuf_component_5fstructure_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Battery : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Electronics.Battery) */ {
 public:
  Battery();
  virtual ~Battery();

  Battery(const Battery& from);

  inline Battery& operator=(const Battery& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Battery& default_instance();

  static inline const Battery* internal_default_instance() {
    return reinterpret_cast<const Battery*>(
               &_Battery_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(Battery* other);

  // implements Message ----------------------------------------------

  inline Battery* New() const PROTOBUF_FINAL { return New(NULL); }

  Battery* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Battery& from);
  void MergeFrom(const Battery& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Battery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double capacity = 1;
  bool has_capacity() const;
  void clear_capacity();
  static const int kCapacityFieldNumber = 1;
  double capacity() const;
  void set_capacity(double value);

  static const int kBatteryFieldNumber = 103;
  static ::google::protobuf::internal::ExtensionIdentifier< ::Electronics::Component,
      ::google::protobuf::internal::MessageTypeTraits< ::Electronics::Battery >, 11, false >
    battery;
  // @@protoc_insertion_point(class_scope:Electronics.Battery)
 private:
  void set_has_capacity();
  void clear_has_capacity();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double capacity_;
  friend struct protobuf_component_5fstructure_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Bluetooth : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Electronics.Bluetooth) */ {
 public:
  Bluetooth();
  virtual ~Bluetooth();

  Bluetooth(const Bluetooth& from);

  inline Bluetooth& operator=(const Bluetooth& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Bluetooth& default_instance();

  static inline const Bluetooth* internal_default_instance() {
    return reinterpret_cast<const Bluetooth*>(
               &_Bluetooth_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(Bluetooth* other);

  // implements Message ----------------------------------------------

  inline Bluetooth* New() const PROTOBUF_FINAL { return New(NULL); }

  Bluetooth* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Bluetooth& from);
  void MergeFrom(const Bluetooth& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Bluetooth* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double frequency = 1;
  bool has_frequency() const;
  void clear_frequency();
  static const int kFrequencyFieldNumber = 1;
  double frequency() const;
  void set_frequency(double value);

  static const int kBluetoothFieldNumber = 108;
  static ::google::protobuf::internal::ExtensionIdentifier< ::Electronics::Component,
      ::google::protobuf::internal::MessageTypeTraits< ::Electronics::Bluetooth >, 11, false >
    bluetooth;
  // @@protoc_insertion_point(class_scope:Electronics.Bluetooth)
 private:
  void set_has_frequency();
  void clear_has_frequency();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double frequency_;
  friend struct protobuf_component_5fstructure_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Camera : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Electronics.Camera) */ {
 public:
  Camera();
  virtual ~Camera();

  Camera(const Camera& from);

  inline Camera& operator=(const Camera& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Camera& default_instance();

  static inline const Camera* internal_default_instance() {
    return reinterpret_cast<const Camera*>(
               &_Camera_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(Camera* other);

  // implements Message ----------------------------------------------

  inline Camera* New() const PROTOBUF_FINAL { return New(NULL); }

  Camera* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Camera& from);
  void MergeFrom(const Camera& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Camera* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double frequency = 1;
  bool has_frequency() const;
  void clear_frequency();
  static const int kFrequencyFieldNumber = 1;
  double frequency() const;
  void set_frequency(double value);

  static const int kCameraFieldNumber = 107;
  static ::google::protobuf::internal::ExtensionIdentifier< ::Electronics::Component,
      ::google::protobuf::internal::MessageTypeTraits< ::Electronics::Camera >, 11, false >
    camera;
  // @@protoc_insertion_point(class_scope:Electronics.Camera)
 private:
  void set_has_frequency();
  void clear_has_frequency();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double frequency_;
  friend struct protobuf_component_5fstructure_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Force_Sensor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Electronics.Force_Sensor) */ {
 public:
  Force_Sensor();
  virtual ~Force_Sensor();

  Force_Sensor(const Force_Sensor& from);

  inline Force_Sensor& operator=(const Force_Sensor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Force_Sensor& default_instance();

  static inline const Force_Sensor* internal_default_instance() {
    return reinterpret_cast<const Force_Sensor*>(
               &_Force_Sensor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(Force_Sensor* other);

  // implements Message ----------------------------------------------

  inline Force_Sensor* New() const PROTOBUF_FINAL { return New(NULL); }

  Force_Sensor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Force_Sensor& from);
  void MergeFrom(const Force_Sensor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Force_Sensor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  static const int kForceSensorFieldNumber = 105;
  static ::google::protobuf::internal::ExtensionIdentifier< ::Electronics::Component,
      ::google::protobuf::internal::MessageTypeTraits< ::Electronics::Force_Sensor >, 11, false >
    force_sensor;
  // @@protoc_insertion_point(class_scope:Electronics.Force_Sensor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_component_5fstructure_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// bbox

// required double length = 1;
inline bool bbox::has_length() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void bbox::set_has_length() {
  _has_bits_[0] |= 0x00000001u;
}
inline void bbox::clear_has_length() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void bbox::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline double bbox::length() const {
  // @@protoc_insertion_point(field_get:Electronics.bbox.length)
  return length_;
}
inline void bbox::set_length(double value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:Electronics.bbox.length)
}

// required double width = 2;
inline bool bbox::has_width() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void bbox::set_has_width() {
  _has_bits_[0] |= 0x00000002u;
}
inline void bbox::clear_has_width() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void bbox::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline double bbox::width() const {
  // @@protoc_insertion_point(field_get:Electronics.bbox.width)
  return width_;
}
inline void bbox::set_width(double value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:Electronics.bbox.width)
}

// required double height = 3;
inline bool bbox::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void bbox::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void bbox::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void bbox::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline double bbox::height() const {
  // @@protoc_insertion_point(field_get:Electronics.bbox.height)
  return height_;
}
inline void bbox::set_height(double value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:Electronics.bbox.height)
}

// -------------------------------------------------------------------

// bounds

// required double lb = 1;
inline bool bounds::has_lb() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void bounds::set_has_lb() {
  _has_bits_[0] |= 0x00000001u;
}
inline void bounds::clear_has_lb() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void bounds::clear_lb() {
  lb_ = 0;
  clear_has_lb();
}
inline double bounds::lb() const {
  // @@protoc_insertion_point(field_get:Electronics.bounds.lb)
  return lb_;
}
inline void bounds::set_lb(double value) {
  set_has_lb();
  lb_ = value;
  // @@protoc_insertion_point(field_set:Electronics.bounds.lb)
}

// required double ub = 2;
inline bool bounds::has_ub() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void bounds::set_has_ub() {
  _has_bits_[0] |= 0x00000002u;
}
inline void bounds::clear_has_ub() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void bounds::clear_ub() {
  ub_ = 0;
  clear_has_ub();
}
inline double bounds::ub() const {
  // @@protoc_insertion_point(field_get:Electronics.bounds.ub)
  return ub_;
}
inline void bounds::set_ub(double value) {
  set_has_ub();
  ub_ = value;
  // @@protoc_insertion_point(field_set:Electronics.bounds.ub)
}

// -------------------------------------------------------------------

// lin_cons

// repeated string var_name = 1;
inline int lin_cons::var_name_size() const {
  return var_name_.size();
}
inline void lin_cons::clear_var_name() {
  var_name_.Clear();
}
inline const ::std::string& lin_cons::var_name(int index) const {
  // @@protoc_insertion_point(field_get:Electronics.lin_cons.var_name)
  return var_name_.Get(index);
}
inline ::std::string* lin_cons::mutable_var_name(int index) {
  // @@protoc_insertion_point(field_mutable:Electronics.lin_cons.var_name)
  return var_name_.Mutable(index);
}
inline void lin_cons::set_var_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Electronics.lin_cons.var_name)
  var_name_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void lin_cons::set_var_name(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:Electronics.lin_cons.var_name)
  var_name_.Mutable(index)->assign(std::move(value));
}
#endif
inline void lin_cons::set_var_name(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  var_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Electronics.lin_cons.var_name)
}
inline void lin_cons::set_var_name(int index, const char* value, size_t size) {
  var_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Electronics.lin_cons.var_name)
}
inline ::std::string* lin_cons::add_var_name() {
  // @@protoc_insertion_point(field_add_mutable:Electronics.lin_cons.var_name)
  return var_name_.Add();
}
inline void lin_cons::add_var_name(const ::std::string& value) {
  var_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Electronics.lin_cons.var_name)
}
#if LANG_CXX11
inline void lin_cons::add_var_name(::std::string&& value) {
  var_name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Electronics.lin_cons.var_name)
}
#endif
inline void lin_cons::add_var_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  var_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Electronics.lin_cons.var_name)
}
inline void lin_cons::add_var_name(const char* value, size_t size) {
  var_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Electronics.lin_cons.var_name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
lin_cons::var_name() const {
  // @@protoc_insertion_point(field_list:Electronics.lin_cons.var_name)
  return var_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
lin_cons::mutable_var_name() {
  // @@protoc_insertion_point(field_mutable_list:Electronics.lin_cons.var_name)
  return &var_name_;
}

// repeated double coefficient = 2;
inline int lin_cons::coefficient_size() const {
  return coefficient_.size();
}
inline void lin_cons::clear_coefficient() {
  coefficient_.Clear();
}
inline double lin_cons::coefficient(int index) const {
  // @@protoc_insertion_point(field_get:Electronics.lin_cons.coefficient)
  return coefficient_.Get(index);
}
inline void lin_cons::set_coefficient(int index, double value) {
  coefficient_.Set(index, value);
  // @@protoc_insertion_point(field_set:Electronics.lin_cons.coefficient)
}
inline void lin_cons::add_coefficient(double value) {
  coefficient_.Add(value);
  // @@protoc_insertion_point(field_add:Electronics.lin_cons.coefficient)
}
inline const ::google::protobuf::RepeatedField< double >&
lin_cons::coefficient() const {
  // @@protoc_insertion_point(field_list:Electronics.lin_cons.coefficient)
  return coefficient_;
}
inline ::google::protobuf::RepeatedField< double >*
lin_cons::mutable_coefficient() {
  // @@protoc_insertion_point(field_mutable_list:Electronics.lin_cons.coefficient)
  return &coefficient_;
}

// required double constant = 3;
inline bool lin_cons::has_constant() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void lin_cons::set_has_constant() {
  _has_bits_[0] |= 0x00000001u;
}
inline void lin_cons::clear_has_constant() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void lin_cons::clear_constant() {
  constant_ = 0;
  clear_has_constant();
}
inline double lin_cons::constant() const {
  // @@protoc_insertion_point(field_get:Electronics.lin_cons.constant)
  return constant_;
}
inline void lin_cons::set_constant(double value) {
  set_has_constant();
  constant_ = value;
  // @@protoc_insertion_point(field_set:Electronics.lin_cons.constant)
}

// required .Electronics.RELATION type = 4;
inline bool lin_cons::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void lin_cons::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void lin_cons::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void lin_cons::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Electronics::RELATION lin_cons::type() const {
  // @@protoc_insertion_point(field_get:Electronics.lin_cons.type)
  return static_cast< ::Electronics::RELATION >(type_);
}
inline void lin_cons::set_type(::Electronics::RELATION value) {
  assert(::Electronics::RELATION_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:Electronics.lin_cons.type)
}

// -------------------------------------------------------------------

// pin

// required string name = 1;
inline bool pin::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pin::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pin::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pin::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& pin::name() const {
  // @@protoc_insertion_point(field_get:Electronics.pin.name)
  return name_.GetNoArena();
}
inline void pin::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Electronics.pin.name)
}
#if LANG_CXX11
inline void pin::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Electronics.pin.name)
}
#endif
inline void pin::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Electronics.pin.name)
}
inline void pin::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Electronics.pin.name)
}
inline ::std::string* pin::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:Electronics.pin.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* pin::release_name() {
  // @@protoc_insertion_point(field_release:Electronics.pin.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void pin::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Electronics.pin.name)
}

// required .Electronics.CLASS pin_class = 2;
inline bool pin::has_pin_class() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void pin::set_has_pin_class() {
  _has_bits_[0] |= 0x00000040u;
}
inline void pin::clear_has_pin_class() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void pin::clear_pin_class() {
  pin_class_ = 7;
  clear_has_pin_class();
}
inline ::Electronics::CLASS pin::pin_class() const {
  // @@protoc_insertion_point(field_get:Electronics.pin.pin_class)
  return static_cast< ::Electronics::CLASS >(pin_class_);
}
inline void pin::set_pin_class(::Electronics::CLASS value) {
  assert(::Electronics::CLASS_IsValid(value));
  set_has_pin_class();
  pin_class_ = value;
  // @@protoc_insertion_point(field_set:Electronics.pin.pin_class)
}

// required .Electronics.FUNCTION_TYPE func_type = 3;
inline bool pin::has_func_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void pin::set_has_func_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void pin::clear_has_func_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void pin::clear_func_type() {
  func_type_ = 10;
  clear_has_func_type();
}
inline ::Electronics::FUNCTION_TYPE pin::func_type() const {
  // @@protoc_insertion_point(field_get:Electronics.pin.func_type)
  return static_cast< ::Electronics::FUNCTION_TYPE >(func_type_);
}
inline void pin::set_func_type(::Electronics::FUNCTION_TYPE value) {
  assert(::Electronics::FUNCTION_TYPE_IsValid(value));
  set_has_func_type();
  func_type_ = value;
  // @@protoc_insertion_point(field_set:Electronics.pin.func_type)
}

// required .Electronics.PHYSICAL_TYPE phys_type = 4;
inline bool pin::has_phys_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void pin::set_has_phys_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void pin::clear_has_phys_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void pin::clear_phys_type() {
  phys_type_ = 55;
  clear_has_phys_type();
}
inline ::Electronics::PHYSICAL_TYPE pin::phys_type() const {
  // @@protoc_insertion_point(field_get:Electronics.pin.phys_type)
  return static_cast< ::Electronics::PHYSICAL_TYPE >(phys_type_);
}
inline void pin::set_phys_type(::Electronics::PHYSICAL_TYPE value) {
  assert(::Electronics::PHYSICAL_TYPE_IsValid(value));
  set_has_phys_type();
  phys_type_ = value;
  // @@protoc_insertion_point(field_set:Electronics.pin.phys_type)
}

// required .Electronics.IO io = 5;
inline bool pin::has_io() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void pin::set_has_io() {
  _has_bits_[0] |= 0x00000200u;
}
inline void pin::clear_has_io() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void pin::clear_io() {
  io_ = 4;
  clear_has_io();
}
inline ::Electronics::IO pin::io() const {
  // @@protoc_insertion_point(field_get:Electronics.pin.io)
  return static_cast< ::Electronics::IO >(io_);
}
inline void pin::set_io(::Electronics::IO value) {
  assert(::Electronics::IO_IsValid(value));
  set_has_io();
  io_ = value;
  // @@protoc_insertion_point(field_set:Electronics.pin.io)
}

// required .Electronics.CONNECTION connection = 6;
inline bool pin::has_connection() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void pin::set_has_connection() {
  _has_bits_[0] |= 0x00000020u;
}
inline void pin::clear_has_connection() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void pin::clear_connection() {
  connection_ = 39;
  clear_has_connection();
}
inline ::Electronics::CONNECTION pin::connection() const {
  // @@protoc_insertion_point(field_get:Electronics.pin.connection)
  return static_cast< ::Electronics::CONNECTION >(connection_);
}
inline void pin::set_connection(::Electronics::CONNECTION value) {
  assert(::Electronics::CONNECTION_IsValid(value));
  set_has_connection();
  connection_ = value;
  // @@protoc_insertion_point(field_set:Electronics.pin.connection)
}

// required bool status = 7;
inline bool pin::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void pin::set_has_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void pin::clear_has_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void pin::clear_status() {
  status_ = false;
  clear_has_status();
}
inline bool pin::status() const {
  // @@protoc_insertion_point(field_get:Electronics.pin.status)
  return status_;
}
inline void pin::set_status(bool value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:Electronics.pin.status)
}

// required .Electronics.bounds v_bound = 8;
inline bool pin::has_v_bound() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pin::set_has_v_bound() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pin::clear_has_v_bound() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pin::clear_v_bound() {
  if (v_bound_ != NULL) v_bound_->::Electronics::bounds::Clear();
  clear_has_v_bound();
}
inline const ::Electronics::bounds& pin::v_bound() const {
  // @@protoc_insertion_point(field_get:Electronics.pin.v_bound)
  return v_bound_ != NULL ? *v_bound_
                         : *::Electronics::bounds::internal_default_instance();
}
inline ::Electronics::bounds* pin::mutable_v_bound() {
  set_has_v_bound();
  if (v_bound_ == NULL) {
    v_bound_ = new ::Electronics::bounds;
  }
  // @@protoc_insertion_point(field_mutable:Electronics.pin.v_bound)
  return v_bound_;
}
inline ::Electronics::bounds* pin::release_v_bound() {
  // @@protoc_insertion_point(field_release:Electronics.pin.v_bound)
  clear_has_v_bound();
  ::Electronics::bounds* temp = v_bound_;
  v_bound_ = NULL;
  return temp;
}
inline void pin::set_allocated_v_bound(::Electronics::bounds* v_bound) {
  delete v_bound_;
  v_bound_ = v_bound;
  if (v_bound) {
    set_has_v_bound();
  } else {
    clear_has_v_bound();
  }
  // @@protoc_insertion_point(field_set_allocated:Electronics.pin.v_bound)
}

// required .Electronics.bounds i_bound = 9;
inline bool pin::has_i_bound() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pin::set_has_i_bound() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pin::clear_has_i_bound() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pin::clear_i_bound() {
  if (i_bound_ != NULL) i_bound_->::Electronics::bounds::Clear();
  clear_has_i_bound();
}
inline const ::Electronics::bounds& pin::i_bound() const {
  // @@protoc_insertion_point(field_get:Electronics.pin.i_bound)
  return i_bound_ != NULL ? *i_bound_
                         : *::Electronics::bounds::internal_default_instance();
}
inline ::Electronics::bounds* pin::mutable_i_bound() {
  set_has_i_bound();
  if (i_bound_ == NULL) {
    i_bound_ = new ::Electronics::bounds;
  }
  // @@protoc_insertion_point(field_mutable:Electronics.pin.i_bound)
  return i_bound_;
}
inline ::Electronics::bounds* pin::release_i_bound() {
  // @@protoc_insertion_point(field_release:Electronics.pin.i_bound)
  clear_has_i_bound();
  ::Electronics::bounds* temp = i_bound_;
  i_bound_ = NULL;
  return temp;
}
inline void pin::set_allocated_i_bound(::Electronics::bounds* i_bound) {
  delete i_bound_;
  i_bound_ = i_bound;
  if (i_bound) {
    set_has_i_bound();
  } else {
    clear_has_i_bound();
  }
  // @@protoc_insertion_point(field_set_allocated:Electronics.pin.i_bound)
}

// required .Electronics.dependence dependents = 10;
inline bool pin::has_dependents() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pin::set_has_dependents() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pin::clear_has_dependents() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pin::clear_dependents() {
  if (dependents_ != NULL) dependents_->::Electronics::dependence::Clear();
  clear_has_dependents();
}
inline const ::Electronics::dependence& pin::dependents() const {
  // @@protoc_insertion_point(field_get:Electronics.pin.dependents)
  return dependents_ != NULL ? *dependents_
                         : *::Electronics::dependence::internal_default_instance();
}
inline ::Electronics::dependence* pin::mutable_dependents() {
  set_has_dependents();
  if (dependents_ == NULL) {
    dependents_ = new ::Electronics::dependence;
  }
  // @@protoc_insertion_point(field_mutable:Electronics.pin.dependents)
  return dependents_;
}
inline ::Electronics::dependence* pin::release_dependents() {
  // @@protoc_insertion_point(field_release:Electronics.pin.dependents)
  clear_has_dependents();
  ::Electronics::dependence* temp = dependents_;
  dependents_ = NULL;
  return temp;
}
inline void pin::set_allocated_dependents(::Electronics::dependence* dependents) {
  delete dependents_;
  dependents_ = dependents;
  if (dependents) {
    set_has_dependents();
  } else {
    clear_has_dependents();
  }
  // @@protoc_insertion_point(field_set_allocated:Electronics.pin.dependents)
}

// -------------------------------------------------------------------

// dependence

// repeated string others = 1;
inline int dependence::others_size() const {
  return others_.size();
}
inline void dependence::clear_others() {
  others_.Clear();
}
inline const ::std::string& dependence::others(int index) const {
  // @@protoc_insertion_point(field_get:Electronics.dependence.others)
  return others_.Get(index);
}
inline ::std::string* dependence::mutable_others(int index) {
  // @@protoc_insertion_point(field_mutable:Electronics.dependence.others)
  return others_.Mutable(index);
}
inline void dependence::set_others(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Electronics.dependence.others)
  others_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void dependence::set_others(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:Electronics.dependence.others)
  others_.Mutable(index)->assign(std::move(value));
}
#endif
inline void dependence::set_others(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  others_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Electronics.dependence.others)
}
inline void dependence::set_others(int index, const char* value, size_t size) {
  others_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Electronics.dependence.others)
}
inline ::std::string* dependence::add_others() {
  // @@protoc_insertion_point(field_add_mutable:Electronics.dependence.others)
  return others_.Add();
}
inline void dependence::add_others(const ::std::string& value) {
  others_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Electronics.dependence.others)
}
#if LANG_CXX11
inline void dependence::add_others(::std::string&& value) {
  others_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Electronics.dependence.others)
}
#endif
inline void dependence::add_others(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  others_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Electronics.dependence.others)
}
inline void dependence::add_others(const char* value, size_t size) {
  others_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Electronics.dependence.others)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
dependence::others() const {
  // @@protoc_insertion_point(field_list:Electronics.dependence.others)
  return others_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
dependence::mutable_others() {
  // @@protoc_insertion_point(field_mutable_list:Electronics.dependence.others)
  return &others_;
}

// -------------------------------------------------------------------

// Component

// required string component_name = 1;
inline bool Component::has_component_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Component::set_has_component_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Component::clear_has_component_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Component::clear_component_name() {
  component_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_component_name();
}
inline const ::std::string& Component::component_name() const {
  // @@protoc_insertion_point(field_get:Electronics.Component.component_name)
  return component_name_.GetNoArena();
}
inline void Component::set_component_name(const ::std::string& value) {
  set_has_component_name();
  component_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Electronics.Component.component_name)
}
#if LANG_CXX11
inline void Component::set_component_name(::std::string&& value) {
  set_has_component_name();
  component_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Electronics.Component.component_name)
}
#endif
inline void Component::set_component_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_component_name();
  component_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Electronics.Component.component_name)
}
inline void Component::set_component_name(const char* value, size_t size) {
  set_has_component_name();
  component_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Electronics.Component.component_name)
}
inline ::std::string* Component::mutable_component_name() {
  set_has_component_name();
  // @@protoc_insertion_point(field_mutable:Electronics.Component.component_name)
  return component_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Component::release_component_name() {
  // @@protoc_insertion_point(field_release:Electronics.Component.component_name)
  clear_has_component_name();
  return component_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Component::set_allocated_component_name(::std::string* component_name) {
  if (component_name != NULL) {
    set_has_component_name();
  } else {
    clear_has_component_name();
  }
  component_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), component_name);
  // @@protoc_insertion_point(field_set_allocated:Electronics.Component.component_name)
}

// required string component_type = 2;
inline bool Component::has_component_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Component::set_has_component_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Component::clear_has_component_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Component::clear_component_type() {
  component_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_component_type();
}
inline const ::std::string& Component::component_type() const {
  // @@protoc_insertion_point(field_get:Electronics.Component.component_type)
  return component_type_.GetNoArena();
}
inline void Component::set_component_type(const ::std::string& value) {
  set_has_component_type();
  component_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Electronics.Component.component_type)
}
#if LANG_CXX11
inline void Component::set_component_type(::std::string&& value) {
  set_has_component_type();
  component_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Electronics.Component.component_type)
}
#endif
inline void Component::set_component_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_component_type();
  component_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Electronics.Component.component_type)
}
inline void Component::set_component_type(const char* value, size_t size) {
  set_has_component_type();
  component_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Electronics.Component.component_type)
}
inline ::std::string* Component::mutable_component_type() {
  set_has_component_type();
  // @@protoc_insertion_point(field_mutable:Electronics.Component.component_type)
  return component_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Component::release_component_type() {
  // @@protoc_insertion_point(field_release:Electronics.Component.component_type)
  clear_has_component_type();
  return component_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Component::set_allocated_component_type(::std::string* component_type) {
  if (component_type != NULL) {
    set_has_component_type();
  } else {
    clear_has_component_type();
  }
  component_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), component_type);
  // @@protoc_insertion_point(field_set_allocated:Electronics.Component.component_type)
}

// required string component_class = 3;
inline bool Component::has_component_class() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Component::set_has_component_class() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Component::clear_has_component_class() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Component::clear_component_class() {
  component_class_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_component_class();
}
inline const ::std::string& Component::component_class() const {
  // @@protoc_insertion_point(field_get:Electronics.Component.component_class)
  return component_class_.GetNoArena();
}
inline void Component::set_component_class(const ::std::string& value) {
  set_has_component_class();
  component_class_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Electronics.Component.component_class)
}
#if LANG_CXX11
inline void Component::set_component_class(::std::string&& value) {
  set_has_component_class();
  component_class_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Electronics.Component.component_class)
}
#endif
inline void Component::set_component_class(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_component_class();
  component_class_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Electronics.Component.component_class)
}
inline void Component::set_component_class(const char* value, size_t size) {
  set_has_component_class();
  component_class_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Electronics.Component.component_class)
}
inline ::std::string* Component::mutable_component_class() {
  set_has_component_class();
  // @@protoc_insertion_point(field_mutable:Electronics.Component.component_class)
  return component_class_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Component::release_component_class() {
  // @@protoc_insertion_point(field_release:Electronics.Component.component_class)
  clear_has_component_class();
  return component_class_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Component::set_allocated_component_class(::std::string* component_class) {
  if (component_class != NULL) {
    set_has_component_class();
  } else {
    clear_has_component_class();
  }
  component_class_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), component_class);
  // @@protoc_insertion_point(field_set_allocated:Electronics.Component.component_class)
}

// repeated .Electronics.pin pin = 4;
inline int Component::pin_size() const {
  return pin_.size();
}
inline void Component::clear_pin() {
  pin_.Clear();
}
inline const ::Electronics::pin& Component::pin(int index) const {
  // @@protoc_insertion_point(field_get:Electronics.Component.pin)
  return pin_.Get(index);
}
inline ::Electronics::pin* Component::mutable_pin(int index) {
  // @@protoc_insertion_point(field_mutable:Electronics.Component.pin)
  return pin_.Mutable(index);
}
inline ::Electronics::pin* Component::add_pin() {
  // @@protoc_insertion_point(field_add:Electronics.Component.pin)
  return pin_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Electronics::pin >*
Component::mutable_pin() {
  // @@protoc_insertion_point(field_mutable_list:Electronics.Component.pin)
  return &pin_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Electronics::pin >&
Component::pin() const {
  // @@protoc_insertion_point(field_list:Electronics.Component.pin)
  return pin_;
}

// required bool nonlin = 5;
inline bool Component::has_nonlin() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Component::set_has_nonlin() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Component::clear_has_nonlin() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Component::clear_nonlin() {
  nonlin_ = false;
  clear_has_nonlin();
}
inline bool Component::nonlin() const {
  // @@protoc_insertion_point(field_get:Electronics.Component.nonlin)
  return nonlin_;
}
inline void Component::set_nonlin(bool value) {
  set_has_nonlin();
  nonlin_ = value;
  // @@protoc_insertion_point(field_set:Electronics.Component.nonlin)
}

// required .Electronics.bbox size = 6;
inline bool Component::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Component::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Component::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Component::clear_size() {
  if (size_ != NULL) size_->::Electronics::bbox::Clear();
  clear_has_size();
}
inline const ::Electronics::bbox& Component::size() const {
  // @@protoc_insertion_point(field_get:Electronics.Component.size)
  return size_ != NULL ? *size_
                         : *::Electronics::bbox::internal_default_instance();
}
inline ::Electronics::bbox* Component::mutable_size() {
  set_has_size();
  if (size_ == NULL) {
    size_ = new ::Electronics::bbox;
  }
  // @@protoc_insertion_point(field_mutable:Electronics.Component.size)
  return size_;
}
inline ::Electronics::bbox* Component::release_size() {
  // @@protoc_insertion_point(field_release:Electronics.Component.size)
  clear_has_size();
  ::Electronics::bbox* temp = size_;
  size_ = NULL;
  return temp;
}
inline void Component::set_allocated_size(::Electronics::bbox* size) {
  delete size_;
  size_ = size;
  if (size) {
    set_has_size();
  } else {
    clear_has_size();
  }
  // @@protoc_insertion_point(field_set_allocated:Electronics.Component.size)
}

// required double weight = 7;
inline bool Component::has_weight() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Component::set_has_weight() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Component::clear_has_weight() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Component::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline double Component::weight() const {
  // @@protoc_insertion_point(field_get:Electronics.Component.weight)
  return weight_;
}
inline void Component::set_weight(double value) {
  set_has_weight();
  weight_ = value;
  // @@protoc_insertion_point(field_set:Electronics.Component.weight)
}

// required double price = 8;
inline bool Component::has_price() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Component::set_has_price() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Component::clear_has_price() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Component::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double Component::price() const {
  // @@protoc_insertion_point(field_get:Electronics.Component.price)
  return price_;
}
inline void Component::set_price(double value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:Electronics.Component.price)
}

// -------------------------------------------------------------------

// Motor

// optional double kt = 1;
inline bool Motor::has_kt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Motor::set_has_kt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Motor::clear_has_kt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Motor::clear_kt() {
  kt_ = 0;
  clear_has_kt();
}
inline double Motor::kt() const {
  // @@protoc_insertion_point(field_get:Electronics.Motor.kt)
  return kt_;
}
inline void Motor::set_kt(double value) {
  set_has_kt();
  kt_ = value;
  // @@protoc_insertion_point(field_set:Electronics.Motor.kt)
}

// optional double ke = 2;
inline bool Motor::has_ke() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Motor::set_has_ke() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Motor::clear_has_ke() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Motor::clear_ke() {
  ke_ = 0;
  clear_has_ke();
}
inline double Motor::ke() const {
  // @@protoc_insertion_point(field_get:Electronics.Motor.ke)
  return ke_;
}
inline void Motor::set_ke(double value) {
  set_has_ke();
  ke_ = value;
  // @@protoc_insertion_point(field_set:Electronics.Motor.ke)
}

// optional double r = 3;
inline bool Motor::has_r() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Motor::set_has_r() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Motor::clear_has_r() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Motor::clear_r() {
  r_ = 0;
  clear_has_r();
}
inline double Motor::r() const {
  // @@protoc_insertion_point(field_get:Electronics.Motor.r)
  return r_;
}
inline void Motor::set_r(double value) {
  set_has_r();
  r_ = value;
  // @@protoc_insertion_point(field_set:Electronics.Motor.r)
}

// optional double vin = 4;
inline bool Motor::has_vin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Motor::set_has_vin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Motor::clear_has_vin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Motor::clear_vin() {
  vin_ = 0;
  clear_has_vin();
}
inline double Motor::vin() const {
  // @@protoc_insertion_point(field_get:Electronics.Motor.vin)
  return vin_;
}
inline void Motor::set_vin(double value) {
  set_has_vin();
  vin_ = value;
  // @@protoc_insertion_point(field_set:Electronics.Motor.vin)
}

// optional double i = 5;
inline bool Motor::has_i() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Motor::set_has_i() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Motor::clear_has_i() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Motor::clear_i() {
  i_ = 0;
  clear_has_i();
}
inline double Motor::i() const {
  // @@protoc_insertion_point(field_get:Electronics.Motor.i)
  return i_;
}
inline void Motor::set_i(double value) {
  set_has_i();
  i_ = value;
  // @@protoc_insertion_point(field_set:Electronics.Motor.i)
}

// optional double torq = 6;
inline bool Motor::has_torq() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Motor::set_has_torq() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Motor::clear_has_torq() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Motor::clear_torq() {
  torq_ = 0;
  clear_has_torq();
}
inline double Motor::torq() const {
  // @@protoc_insertion_point(field_get:Electronics.Motor.torq)
  return torq_;
}
inline void Motor::set_torq(double value) {
  set_has_torq();
  torq_ = value;
  // @@protoc_insertion_point(field_set:Electronics.Motor.torq)
}

// optional double vel = 7;
inline bool Motor::has_vel() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Motor::set_has_vel() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Motor::clear_has_vel() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Motor::clear_vel() {
  vel_ = 0;
  clear_has_vel();
}
inline double Motor::vel() const {
  // @@protoc_insertion_point(field_get:Electronics.Motor.vel)
  return vel_;
}
inline void Motor::set_vel(double value) {
  set_has_vel();
  vel_ = value;
  // @@protoc_insertion_point(field_set:Electronics.Motor.vel)
}

// -------------------------------------------------------------------

// Voltage_Regulator

// repeated .Electronics.lin_cons cons = 1;
inline int Voltage_Regulator::cons_size() const {
  return cons_.size();
}
inline void Voltage_Regulator::clear_cons() {
  cons_.Clear();
}
inline const ::Electronics::lin_cons& Voltage_Regulator::cons(int index) const {
  // @@protoc_insertion_point(field_get:Electronics.Voltage_Regulator.cons)
  return cons_.Get(index);
}
inline ::Electronics::lin_cons* Voltage_Regulator::mutable_cons(int index) {
  // @@protoc_insertion_point(field_mutable:Electronics.Voltage_Regulator.cons)
  return cons_.Mutable(index);
}
inline ::Electronics::lin_cons* Voltage_Regulator::add_cons() {
  // @@protoc_insertion_point(field_add:Electronics.Voltage_Regulator.cons)
  return cons_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Electronics::lin_cons >*
Voltage_Regulator::mutable_cons() {
  // @@protoc_insertion_point(field_mutable_list:Electronics.Voltage_Regulator.cons)
  return &cons_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Electronics::lin_cons >&
Voltage_Regulator::cons() const {
  // @@protoc_insertion_point(field_list:Electronics.Voltage_Regulator.cons)
  return cons_;
}

// -------------------------------------------------------------------

// H_Bridge

// optional .Electronics.bounds logic_level = 1;
inline bool H_Bridge::has_logic_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void H_Bridge::set_has_logic_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void H_Bridge::clear_has_logic_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void H_Bridge::clear_logic_level() {
  if (logic_level_ != NULL) logic_level_->::Electronics::bounds::Clear();
  clear_has_logic_level();
}
inline const ::Electronics::bounds& H_Bridge::logic_level() const {
  // @@protoc_insertion_point(field_get:Electronics.H_Bridge.logic_level)
  return logic_level_ != NULL ? *logic_level_
                         : *::Electronics::bounds::internal_default_instance();
}
inline ::Electronics::bounds* H_Bridge::mutable_logic_level() {
  set_has_logic_level();
  if (logic_level_ == NULL) {
    logic_level_ = new ::Electronics::bounds;
  }
  // @@protoc_insertion_point(field_mutable:Electronics.H_Bridge.logic_level)
  return logic_level_;
}
inline ::Electronics::bounds* H_Bridge::release_logic_level() {
  // @@protoc_insertion_point(field_release:Electronics.H_Bridge.logic_level)
  clear_has_logic_level();
  ::Electronics::bounds* temp = logic_level_;
  logic_level_ = NULL;
  return temp;
}
inline void H_Bridge::set_allocated_logic_level(::Electronics::bounds* logic_level) {
  delete logic_level_;
  logic_level_ = logic_level;
  if (logic_level) {
    set_has_logic_level();
  } else {
    clear_has_logic_level();
  }
  // @@protoc_insertion_point(field_set_allocated:Electronics.H_Bridge.logic_level)
}

// repeated .Electronics.lin_cons linear_cons = 2;
inline int H_Bridge::linear_cons_size() const {
  return linear_cons_.size();
}
inline void H_Bridge::clear_linear_cons() {
  linear_cons_.Clear();
}
inline const ::Electronics::lin_cons& H_Bridge::linear_cons(int index) const {
  // @@protoc_insertion_point(field_get:Electronics.H_Bridge.linear_cons)
  return linear_cons_.Get(index);
}
inline ::Electronics::lin_cons* H_Bridge::mutable_linear_cons(int index) {
  // @@protoc_insertion_point(field_mutable:Electronics.H_Bridge.linear_cons)
  return linear_cons_.Mutable(index);
}
inline ::Electronics::lin_cons* H_Bridge::add_linear_cons() {
  // @@protoc_insertion_point(field_add:Electronics.H_Bridge.linear_cons)
  return linear_cons_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Electronics::lin_cons >*
H_Bridge::mutable_linear_cons() {
  // @@protoc_insertion_point(field_mutable_list:Electronics.H_Bridge.linear_cons)
  return &linear_cons_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Electronics::lin_cons >&
H_Bridge::linear_cons() const {
  // @@protoc_insertion_point(field_list:Electronics.H_Bridge.linear_cons)
  return linear_cons_;
}

// -------------------------------------------------------------------

// Micro_Controller

// optional .Electronics.bounds logic_level = 1;
inline bool Micro_Controller::has_logic_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Micro_Controller::set_has_logic_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Micro_Controller::clear_has_logic_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Micro_Controller::clear_logic_level() {
  if (logic_level_ != NULL) logic_level_->::Electronics::bounds::Clear();
  clear_has_logic_level();
}
inline const ::Electronics::bounds& Micro_Controller::logic_level() const {
  // @@protoc_insertion_point(field_get:Electronics.Micro_Controller.logic_level)
  return logic_level_ != NULL ? *logic_level_
                         : *::Electronics::bounds::internal_default_instance();
}
inline ::Electronics::bounds* Micro_Controller::mutable_logic_level() {
  set_has_logic_level();
  if (logic_level_ == NULL) {
    logic_level_ = new ::Electronics::bounds;
  }
  // @@protoc_insertion_point(field_mutable:Electronics.Micro_Controller.logic_level)
  return logic_level_;
}
inline ::Electronics::bounds* Micro_Controller::release_logic_level() {
  // @@protoc_insertion_point(field_release:Electronics.Micro_Controller.logic_level)
  clear_has_logic_level();
  ::Electronics::bounds* temp = logic_level_;
  logic_level_ = NULL;
  return temp;
}
inline void Micro_Controller::set_allocated_logic_level(::Electronics::bounds* logic_level) {
  delete logic_level_;
  logic_level_ = logic_level;
  if (logic_level) {
    set_has_logic_level();
  } else {
    clear_has_logic_level();
  }
  // @@protoc_insertion_point(field_set_allocated:Electronics.Micro_Controller.logic_level)
}

// -------------------------------------------------------------------

// Battery

// optional double capacity = 1;
inline bool Battery::has_capacity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Battery::set_has_capacity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Battery::clear_has_capacity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Battery::clear_capacity() {
  capacity_ = 0;
  clear_has_capacity();
}
inline double Battery::capacity() const {
  // @@protoc_insertion_point(field_get:Electronics.Battery.capacity)
  return capacity_;
}
inline void Battery::set_capacity(double value) {
  set_has_capacity();
  capacity_ = value;
  // @@protoc_insertion_point(field_set:Electronics.Battery.capacity)
}

// -------------------------------------------------------------------

// Bluetooth

// optional double frequency = 1;
inline bool Bluetooth::has_frequency() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Bluetooth::set_has_frequency() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Bluetooth::clear_has_frequency() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Bluetooth::clear_frequency() {
  frequency_ = 0;
  clear_has_frequency();
}
inline double Bluetooth::frequency() const {
  // @@protoc_insertion_point(field_get:Electronics.Bluetooth.frequency)
  return frequency_;
}
inline void Bluetooth::set_frequency(double value) {
  set_has_frequency();
  frequency_ = value;
  // @@protoc_insertion_point(field_set:Electronics.Bluetooth.frequency)
}

// -------------------------------------------------------------------

// Camera

// optional double frequency = 1;
inline bool Camera::has_frequency() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Camera::set_has_frequency() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Camera::clear_has_frequency() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Camera::clear_frequency() {
  frequency_ = 0;
  clear_has_frequency();
}
inline double Camera::frequency() const {
  // @@protoc_insertion_point(field_get:Electronics.Camera.frequency)
  return frequency_;
}
inline void Camera::set_frequency(double value) {
  set_has_frequency();
  frequency_ = value;
  // @@protoc_insertion_point(field_set:Electronics.Camera.frequency)
}

// -------------------------------------------------------------------

// Force_Sensor

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace Electronics

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Electronics::RELATION> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Electronics::RELATION>() {
  return ::Electronics::RELATION_descriptor();
}
template <> struct is_proto_enum< ::Electronics::IO> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Electronics::IO>() {
  return ::Electronics::IO_descriptor();
}
template <> struct is_proto_enum< ::Electronics::CLASS> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Electronics::CLASS>() {
  return ::Electronics::CLASS_descriptor();
}
template <> struct is_proto_enum< ::Electronics::FUNCTION_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Electronics::FUNCTION_TYPE>() {
  return ::Electronics::FUNCTION_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Electronics::PHYSICAL_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Electronics::PHYSICAL_TYPE>() {
  return ::Electronics::PHYSICAL_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Electronics::CONNECTION> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Electronics::CONNECTION>() {
  return ::Electronics::CONNECTION_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_component_5fstructure_2eproto__INCLUDED
